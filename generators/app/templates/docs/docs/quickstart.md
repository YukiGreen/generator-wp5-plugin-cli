
<h1 style="font-size: 30px;text-align: center">插件开发模板使用说明</h1>

本项目提供的是一个供插件开发的基础结构目录

# 目录结构

```markdown
.
├── build # webpack配置文件
├── config # 相关配置变量定义
├── docs # 前端文档视图层
├── examples # 前端视图层
├── packages # 主要插件定义目录
│   ├── helloModule # 欢迎模块
│   ├── ... # 等等其他模块
├── src # 插件相关其他配置如国际化、样式、store、services等
│   ├── components # 公共组件
│   ├── i18ns # 插件内国际化文件
│   ├── mock # mock数据文件
│   ├── routers # 插件内路由文件
│   ├── services # 请求接口定义文件
│   ├── store # 状态管理文件
│   ├── styles # 样式文件汇总
│   ├── utils # 工具文件
│   ├── index.js # 导出插件资源
├── test # 测试文件
├── types # 类型定义文件
├── static # 静态文件
├── .babelrc # babel配置文件
├── .gitignore # git上传忽略文件
├── .npmrc # npm配置文件
├── .yarnrc # yarn配置文件
├── eslintrc.js # eslint配置文件
├── components.js # babel配置文件
├── package.json # 包管理文件
├── tsconfig.json # typescript配置文件
└── tslint.json # typescript校验文件
.
```


# 使用方法

## 第一步: 将本项目克隆到本地

``` shell script
$ git clone git@git.yfb.sunline.cn:edsp-vue/vue2.0-resources/pte-plugin-cli.git
```

## 第二步: 安装该项目的基础依赖

``` shell script
$ cd pte-plugin-cli/

$ yarn
```

## 第三步: 新建插件目录

### 3.1 开发子模块: 在packages目录下创建子模块目录,并在该目录下开发子模块

如：当前模块为'header-one',子模块为'hello-world',那我们创建helloModule目录用来存放'hello-world'子模块相关文件

```markdown
└── packages
    ├── helloModule # helloModule模块
    |   ├── src
    |   │   └── index.vue # helloModule主页面
    |   └── index.less # 该子模块样式文件
    |   └── index.js # 该子模块定义install方法并导出
    |——....  #其他模块
    └src
      |── index.js # packages中定义的所有模块统一导出, 可直接在在项目目录下执行“yarn build:entry”, 自动生成该文件中的内容，无需手动导入，每次新增组件或修改组件文件夹名称后，可执行一遍该命令，自动生成该文件内容
```
执行`yarn add:component helloModule(组件英文名,自定义) pte(组件样式前缀, 自定义) 欢迎（组件中文名,自定义,不输入时默认显示英文名）`，可自动创建子模块相关文件。
### 3.2 国际化: 在 src 目录下的 i18ns 文件夹内添加对应的国际化内容

```markdown
└── src
    ├── i18ns # 国际化配置
    ├──   |——en # 英文国际化的文件夹
    |     |   ├── helloModule.ts # 模块一中文国际化映射表
    |     |   └── ***.ts # 其他模块中文国际化映射表
    |     ├──zh-CN # 中文国际化的文件夹
    |           ├── helloModule.ts # 模块一中文国际化映射表
    |           └── ***.ts # 其他模块中文国际化映射表
    └── index.js # 国际化配置导出, 可直接在项目目录下执行“yarn build:lang” 自动生成该文件中的内容，每次新增国际化文件后，可再执行一遍该命令
```


### 3.3 Vuex:在 src 目录下的 store 中的 modules 文件夹配置全局状态管理的 module

```markdown
└── src
    ├── store # 全局状态管理
    │       └── modules
    │               ├── helloModule
    │               │       └── index.ts
    │               └── mutation-types.ts
    └── index.js  # store的Module导出， 更新store后，可直接在在项目目录下执行“yarn build:entry”, 自动生成该文件中的内容，无需手动导入
```

### 3.4 样式文件管理
各个子组件都可以有自己的样式文件，写在组件文件夹中的index.less中，写完之后，可执行“yarn build:style”, 自动将该各个组件中的样式文件打包到`src/styles/index.less`文件夹中，该文件在src/index.js中使用

```markdown
└── packages
    ├── helloModule # helloModule模块
    |   ├── src
    |   │   └── index.vue
    |   |—— index.less # helloModule模块的样式文件
    |   └── index.js
    |——....  #其他模块
└── src
    ├── style # 汇总的样式文件夹
    │       └── index.less # 该文件中的内容，可使用“yarn build:style”自动生成
    └── index.js  # 总样式文件在该文件夹中导入，可直接在在项目目录下执行“yarn build:entry”, 自动生成该文件中的内容，无需手动导入
```

### 3.5 路由文件管理
组件内的路由跳转配置，可写在`src/routers/index.ts`中，结构按照官网的`RouteConfig`结构定义，范例结构如下：

```markdown
import TshelloModule from '../../packages/tshelloModule';
import TsHelloEdit from '../../packages/tsHelloEdit';

export default [
  {
    path: 'header-one',
    name: 'header-one',
    show: true,
    component: { render: (e) => e("router-view") },
    children: [
      {
        path: 'ts-hello-world',
        name: 'ts-hello-world',
        show: true,
        component: TshelloModule,
      },
      {
        path: 'ts-hello-edit',
        name: 'ts-hello-edit',
        show: false,
        component: TsHelloEdit,
      }
    ]
  }
];
```

### 3.6 在 src 目录下 index.js 文件解析

src 目录下 index.js 文件解析下的内容大致如下：

```javascript
/* Automatically generated by './build/bin/build-entry.js' */
import TshelloModule from '../packages/tshelloModule/index.js';
import TsHelloEdit from '../packages/tsHelloEdit/index.js';
import './styles/index.less';
import pluginLang from './i18ns/index'; // 导出国际化文件
import pluginRouters from './routers'; // 导出路由文件
import pluginStore from './store/modules/helloModule/index'; // 导出store
const components = [
  TshelloModule,
  TsHelloEdit
];
const install = function(Vue, opts = {}) {
  components.forEach(component => {
    Vue.component(component.name, component);
  });
};
/* istanbul ignore if */
if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue);
}
export {
  install,
  pluginLang,
  pluginStore,
  pluginRouters,
  TshelloModule,
  TsHelloEdit
};
export default {
  version: '1.0.0',
  install,
  TshelloModule,
  TsHelloEdit
};
```

### 3.5 模块开发预览

#### 3.5.1 在当前模板提供的简易项目中预览
- 首先：在`examples`文件夹下的`main.ts`中写入如下语句：
```typescript
import HelloUI, { pluginStore, pluginLang, pluginRouters } from '../src/index.js';

Vue.use(HelloUI);
// 注册store
store.registerModule('pluginStore', pluginStore);
// 扩展国际化
i18n.mergeLocaleMessage('zh', pluginLang["zh-CN"]);
i18n.mergeLocaleMessage('en', pluginLang.en);
// 注册路由
pluginRouters.forEach(ele => {
  vueIns.$router.addRoute('component', ele);
})
```
PS: HelloUI 这个名字可以根据具体插件内容自定义

## 第四步: 本地调试

```shell script
yarn dev:docs # 看到的是docs页面

yarn dev:demo # 看到的是examples页面
```
即可看到在界面上看到根据路由生成的菜单，点击菜单可实现对应的路由跳转，点击编辑可根据我们写的路由跳转到编辑界面，具体效果请参见helloModule模块页面效果。

## 第五步: 在壳子项目中联调

将build\webpack.lib.conf.js文件中的输出目录改为壳子项目该插件的包下，如下：
```javascript
...
path: path.resolve(process.cwd(), '../../../edsp/edsp-ui-19-M1/edsp-ui/node_modules/pte-plugin/lib'),
...
```
然后执行如下命令，即可在壳子项目上和安装了该依赖一样使用该插件，插件中修改了代码，壳子项目中可实时得到更新。
```shell script
yarn dev
```

## 第六步:打包发布
### 流水线发布
步骤如下：
1. yarn项目依赖安装: yarn
2. yarn deploy
3. npm-publish: npm publish --registry=http://nexus.yfb.sunline.cn:8099/nexus3/repository/npm-private/

壳子项目将yarn和npm的源指向私库，然后执行 npm install 或者 yarn 安装即可。

### 本地打tgz包
步骤如下: 
​执行以下命令后会在当前目录分别生成 lib 目录 和 .tgz 文件

```shell script
yarn deploy
yarn pack
```
然后将生成的 tgz 包移至需要安装此模块的项目,并使用 npm 或 yarn 本地安装

```shell script
yarn add file:tgz包文件名
```

## 第七步:在使用此模块的项目中导入模块,可按需导入;
假如我们在package.json中给插件取得名字叫`pte-plugin`, 模块导入范例如下:

```javascript
import HelloUI, { pluginStore, pluginLang, pluginRouters } from 'pte-plugin'; // HelloUI 名字可根据插件内容自定义

Vue.use(HelloUI);
// 注册store
store.registerModule('pluginStore', pluginStore);
// 扩展国际化
i18n.mergeLocaleMessage('zh', pluginLang["zh-CN"]);
i18n.mergeLocaleMessage('en', pluginLang.en);
// 注册路由
pluginRouters.forEach(ele => {
  vueIns.$router.addRoute('component', ele);
})
```

## 第八步:使用

在使用此模块的项目直接使用,如：
:::demo

```html
<template>
  <ts-hello-world></ts-hello-world>
</template>
<script>
  export default {
    data() {
      return {};
    }
  };
</script>
```
:::

## 第九步: 将插件在目标项目中联调
1. 在插件项目根目录下执行
```
yarn link
```
2. 成功后，在目标项目根目录下执行：
```
yarn link 插件名(package.json中的name)
```
3. 在目标项目的 `webpack.base.conf.js`中修改如下两处配置：
```
resolve: {
    ...
    symlinks: false,
    alias: {
      'vue$': resolve('node_modules/vue/dist/vue.esm.js'),
      ...
    },
  },
```
4. 在插件项目中执行
```
yarn dev
```
5. 在目标项目中再做上面第七步、第八步的配置使用即可。
### FAQ:
......
